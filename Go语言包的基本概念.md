# Go 语言包的基本概念

**本文地址**：[xuanhao44/Go_Learn](https://github.com/xuanhao44/Go_Learn)

## 0 教程与简介

### 0.1 简介

包的讲解也许比语法更加复杂。要学完很多才能清楚。本篇只是开个头讲 Go 语言包的基本概念，暂时不涉及实践部分(不看完本篇实践也是白瞎)。

之后还会学的包的知识：

- Go 语言常用内置包简介
- Go 语言自定义包
- Go 语言 package（创建包）
- ...

### 0.2 参考

- [Go 语言结构 | 菜鸟教程 (runoob.com)](https://www.runoob.com/go/go-program-structure.html)
- [Go语言包的基本概念 (biancheng.net)](http://c.biancheng.net/view/5394.html)
- [Go语言常用内置包简介 (biancheng.net)](http://c.biancheng.net/view/4306.html)
- ...

## 1 Go 源码分析

```go
package main

import "fmt"

func main() {
   fmt.Println("Hello, World!")
}
```

让我们来看下以上程序的有关包的部分：

1. **包声明**：第一行代码 `package main` 定义了包名。

   你必须在源文件中非注释的第一行**指明这个文件属于哪个包**，如：`package main`。

   `package main` 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 `main` 的包。

2. **引入包**：下一行 `import "fmt"` 告诉 Go 编译器这个程序需要使用 `fmt` 包（的函数，或其他元素）。

   `fmt` 包实现了格式化 IO（输入/输出）的函数。

3. **函数**：下一行 `func main()` 是程序开始执行的函数。

   `main` 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 `init()` 函数则会先执行该函数）。

## 2 Go 语言包的基本概念

Go 语言是使用包来组织源代码的，包（package）是多个 Go 源码的集合，是一种高级的代码复用方案。

Go 语言中为我们提供了很多内置包，如 `fmt`、`os`、`io` 等。

任何源代码文件必须属于某个包，同时源码文件的第一行有效代码必须是 `package pacakgeName ` 语句，通过该语句声明自己所在的包。

### 2.1 包的基本概念

Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。

包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是包在引用时一般使用全路径引用。

比如在 `GOPATH/src/a/b/ ` 下定义一个包 c。在包 c 的源码中只需声明为 `package c`，而不是声明为 `package a/b/c`，但是在导入 c 包时，需要带上路径，例如 `import "a/b/c"`。

包的习惯用法：

- 包名一般是**小写**的，使用一个简短且有意义的名称。
- 包名一般要和所在的目录同名，也可以不同，包名中不能包含 `- ` 等特殊符号。
- 包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到`GOPATH/src/github.com/userName/projectName `目录下。
- 包名为 `main` 的包为**应用程序的入口包**，编译不包含 `main` 包的源码文件时不会得到可执行文件。
- 一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。

### 2.2 包的导入

要在代码中引用其他包的内容，需要使用 `import` 关键字导入使用的包。具体语法如下：

```go
import "包的路径"
```

注意事项：

- import 导入语句通常放在源码文件开头包声明语句的下面
- 导入的包名需要使用双引号包裹起来
- **包名是从 `GOPATH/src/ ` 后开始计算的**，使用 `/ ` 进行路径分隔


包的导入有两种写法，分别是**单行导入**和**多行导入**。两种导入方法的导入代码效果是一致的。

#### 2.2.1 单行导入

```go
import "包 1 的路径"
import "包 2 的路径"
```

#### 2.2.2 多行导入

当多行导入时，包名在 import 中的顺序不影响导入效果。

```go
import (
    "包 1 的路径"
    "包 2 的路径"
)
```

### 2.3 包的导入路径

包的引用路径有两种写法，分别是**全路径导入**和**相对路径导入**。

#### 2.3.1 全路径导入

包的绝对路径就是 `GOROOT/src/`或`GOPATH/src/` 后面包的存放路径，如下所示：

```go
import "lab/test"
import "database/sql/driver"
import "database/sql"
```

上面代码的含义如下：

- test 包是自定义的包，其源码位于 `GOPATH/src/lab/test ` 目录下
- driver 包的源码位于 `GOROOT/src/database/sql/driver ` 目录下
- sql 包的源码位于 `GOROOT/src/database/sql ` 目录下

#### 2.3.2 相对路径导入

相对路径只能用于导入 `GOPATH ` 下的包，**标准包的导入只能使用全路径导入**。

例如包 a 的所在路径是 `GOPATH/src/lab/a`，包 b 的所在路径为 `GOPATH/src/lab/b`，如果在包 b 中导入包 a ，则可以使用相对路径导入方式。示例如下：

```go
// 相对路径导入
import "../a"
```

当然了，也可以使用上面的全路径导入，如下所示：

```go
// 全路径导入
import "lab/a"
```

### 2.4 包的引用格式

包的引用有四种格式，下面以 `fmt` 包为例来分别演示一下这四种格式。

#### 2.4.1 标准引用格式

```go
import "fmt"
```

此时可以用 `fmt.` 作为前缀来使用 `fmt` 包中的方法，这是常用的一种方式。

示例代码如下：

```go
package main

import "fmt"

func main() {
    fmt.Println("xuanhao44")
}
```

#### 2.4.2 自定义别名引用格式

在导入包的时候，我们还可以为导入的包设置别名，如下所示：

```go
import F "fmt"
```

其中 `F` 就是 `fmt` 包的别名，使用时我们可以使用 `F.` 来代替标准引用格式的 `fmt.` 来作为前缀使用 `fmt` 包中的方法。

示例代码如下：

```go
package main

import F "fmt"

func main() {
    F.Println("xuanhao44")
}
```

#### 2.4.3 省略引用格式

```go
import . "fmt"
```

这种格式相当于把 `fmt` 包直接合并到当前程序中，在使用 `fmt` 包内的方法是可以不用加前缀 `fmt.`，直接引用。

示例代码如下：

```go
package main

import . "fmt"

func main() {
    //不需要加前缀 fmt.
    Println("xuanhao44")
}
```

#### 2.4.4 匿名引用格式

在引用某个包时，如果只是希望执行包初始化的 `init` 函数，而不使用包内部的数据时，可以使用匿名引用格式，如下所示：

```go
import _ "fmt"
```

匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。

**使用标准格式引用包，但是代码中却没有使用包，编译器会报错。**

如果包中有 `init` 初始化函数，则通过 `import _ "包的路径" ` 这种方式引用包，仅执行包的初始化函数，即使包没有 `init` 初始化函数，也不会引发编译器报错。

示例代码如下：

```go
package main

import (
    _ "database/sql"
    "fmt"
)

func main() {
    fmt.Println("xuanhao44")
}
```

注意：

- 一个包可以有多个 `init` 函数，包加载时会执行全部的 `init` 函数，但并不能保证执行顺序，所以不建议在一个包中放入多个 `init` 函数，将需要初始化的逻辑放到一个 `init` 函数里面。
- 包不能出现环形引用的情况，比如包 a 引用了包 b，包 b 引用了包 c，如果包 c 又引用了包 a，则编译不能通过。
- 包的重复引用是允许的，比如包 a 引用了包 b 和包 c，包 b 和包 c 都引用了包 d。这种场景相当于重复引用了 d，这种情况是允许的，并且 Go 编译器保证包 d 的 `init` 函数只会执行一次。

### 2.5 包加载

通过前面一系列的学习相信大家已经大体了解了 Go 程序的启动和加载过程，在执行 `main` 包的 `main` 函数之前， Go 引导程序会先对整个程序的包进行初始化。整个执行的流程如下图所示。

![Go_包的初始化][Go_包的初始化]


Go语言包的初始化有如下特点：

- 包初始化程序从 `main` 函数引用的包开始，逐级查找包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图。
- Go 编译器会将有向无环图转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化。
- 单个包的初始化过程如上图所示，先初始化常量，然后是全局变量，最后执行包的 `init` 函数。

## 3 Go 语言常用内置包简介

**标准的 Go 语言代码库**中包含了大量的包，并且在安装 Go 的时候多数会自动安装到系统中。

我们可以在 `$GOROOT/src/pkg` 目录中查看这些包。

![Go标准库][Go标准库]

下面简单介绍一些我们开发中常用的包。

### 3.1 `fmt`

`fmt` 包实现了格式化的标准输入输出，这与 C 语言中的 `printf` 和 `scanf` 类似。其中的 `fmt.Printf()` 和 `fmt.Println()` 是开发者使用最为频繁的函数。

格式化短语派生于 C 语言，一些短语（%- 序列）是这样使用：

- `%v`：默认格式的值。当打印结构时，加号（%+v）会增加字段名；
- `%#v`：Go样式的值表达
- `%T`：带有类型的 Go 样式的值表达。

### 3.2 `io`

这个包提供了原始的 I/O 操作界面。它主要的任务是对 `os` 包这样的原始的 I/O 进行封装，增加一些其他相关，使其具有抽象功能用在公共的接口上。

### 3.3 `bufio`

`bufio` 包通过对 io 包的封装，提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。

在 `bufio` 各个组件内部都维护了一个缓冲区，数据读写操作都直接通过缓存区进行。当发起一次读写操作时，会首先尝试从缓冲区获取数据，只有当缓冲区没有数据时，才会从数据源获取数据更新缓冲。

### 3.4 `sort`

`sort` 包提供了用于对切片和用户定义的集合进行排序的功能。

### 3.5 `strconv`

`strconv` 包提供了将字符串转换成基本数据类型，或者从基本数据类型转换为字符串的功能。

### 3.6 `os`

`os` 包提供了不依赖平台的操作系统函数接口，设计像 Unix 风格，但错误处理是 go 风格，当 `os` 包使用时，如果失败后返回错误类型而不是错误数量。

### 3.7 `sync`

`sync` 包实现多线程中锁机制以及其他同步互斥机制。

### 3.8 `flag`

`flag` 包提供命令行参数的规则定义和传入参数解析的功能。绝大部分的命令行程序都需要用到这个包。

### 3.9 `encoding/json`

JSON 是目前广泛用做网络程序中的通信格式。`encoding/json` 包提供了对 JSON 的基本支持，比如从一个对象序列化为 JSON 字符串，或者从 JSON 字符串反序列化出一个具体的对象等。

### 3.10 `html/template`

主要实现了 web 开发中生成 html 的 template 的一些函数。

### 3.11 `net/http`

`net/http` 包提供 HTTP 相关服务，主要包括 http 请求、响应和 URL 的解析，以及基本的 http 客户端和扩展的 http 服务。

通过 `net/http` 包，只需要数行代码，即可实现一个爬虫或者一个 Web 服务器，这在传统语言中是无法想象的。

### 3.12 `reflect`

`reflect` 包实现了运行时反射，允许程序通过抽象类型操作对象。通常用于处理静态类型 `interface{}` 的值，并且通过 `Typeof` 解析出其动态类型信息，通常会返回一个有接口类型 `Type` 的对象。

### 3.13 `os/exec`

`os/exec` 包提供了执行自定义 linux 命令的相关实现。

### 3.14 `strings`

`strings` 包主要是处理字符串的一些函数集合，包括合并、查找、分割、比较、后缀检查、索引、大小写处理等等。

`strings` 包与 `bytes` 包的函数接口功能基本一致。

### 3.15 `bytes`

`bytes` 包提供了对字节切片进行读写操作的一系列函数。字节切片处理的函数比较多，分为基本处理函数、比较函数、后缀检查函数、索引函数、分割函数、大小写处理函数和子切片处理函数等。

### 3.16 `log`

`log` 包主要用于在程序中输出日志。

`log` 包中提供了三类日志输出接口，`Print`、`Fatal` 和 `Panic`。

- `Print` 是普通输出；
- `Fatal` 是在执行完 `Print` 后，执行 `os.Exit(1)`；
- `Panic` 是在执行完 `Print` 后调用 `panic()` 方法。

<!-- 图片 -->

[Go_包的初始化]:.assets/Go_包的初始化.gif
[Go_包的初始化]:https://typora-1304621073.cos.ap-guangzhou.myqcloud.com/typora/Go_%E5%8C%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.gif
[Go标准库]:.assets/Go标准库.png

[Go标准库]:https://typora-1304621073.cos.ap-guangzhou.myqcloud.com/typora/Go%E6%A0%87%E5%87%86%E5%BA%93.png